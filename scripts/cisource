#!/usr/bin/env python3

import argparse
import sys
import os
from os import path
import shutil
from subprocess import check_call, check_output
from collections import namedtuple

from lib import foreach_repo

Series = namedtuple('Series', 'codename version')

parser = argparse.ArgumentParser(description="Source package all Pop!_OS repositories")
parser.add_argument("repos", nargs="*", default=[])
args = parser.parse_args(sys.argv[1:])

POP_DIR = path.dirname(path.dirname(path.abspath(__file__)))
BUILD_DIR = path.join(POP_DIR, '_build')
SOURCE_DIR = path.join(BUILD_DIR, 'deb_source')

build_series = {
    'artful': '17.10',
    'bionic': '18.04',
}

CHANGELOG = """{name} ({version}) {codename}; urgency=low

  * Auto Build

 -- {maintainer}  {datetime}
"""


def iprint(level, value):
    indent = ' ' * (level * 4)
    print('>>> ' + indent + str(value))


def git_ids_and_branches(cwd):
    """
    Returns a `dict` mapping each commit ID to a list of branches.

    `git ls-remote` will return something like::

        f73e8fc2c5bb5756032c35b6be1fcd84106413b1	refs/heads/overhaul
        ffb788cccfe0cd7feedcfe8f0b8e9154097a46ca	refs/heads/master
        f73e8fc2c5bb5756032c35b6be1fcd84106413b1	refs/heads/test_bionic

    For which this function would return::

        {
            'f73e8fc2c5bb5756032c35b6be1fcd84106413b1': ['overhaul', 'test_bionic'],
            'ffb788cccfe0cd7feedcfe8f0b8e9154097a46ca':	['master'],
        }
    """
    check_call(['git', 'fetch', 'origin'], cwd=cwd)
    o = check_output(['git', 'ls-remote', '--heads', 'origin'], cwd=cwd)
    prefix = 'refs/heads/'
    result = {}
    for line in o.decode().splitlines():
        (_id, rawbranch) = line.split('\t')
        assert rawbranch.startswith(prefix)
        branch = rawbranch[len(prefix):]
        if _id not in result:
            result[_id] = []
        result[_id].append(branch)
    return result


def git_clean(cwd):
    check_call(['git', 'clean', '-xfd'], cwd=cwd)


def git_checkout_id(cwd, _id):
    check_call(['git', 'checkout', '--force', '--detach', _id], cwd=cwd)
    check_call(['git', 'submodule', 'sync', '--recursive'], cwd=cwd)
    check_call(['git', 'submodule', 'update', '--init', '--recursive'], cwd=cwd)
    git_clean(cwd)


def git_datetime_id(cwd, _id):
    o = check_output(["git", "log", "-1", "--pretty=format:%cd", _id], cwd=cwd)
    return o.decode().strip()


def git_archive_id(cwd, _id):
    return check_output(["git", "archive", "--format", "tar", _id], cwd=cwd)


def parse_branch(branch):
    parts = branch.split('_')
    assert len(parts) <= 2
    pocket = parts[0]
    codename = (None if len(parts) < 2 else parts[1])
    return (pocket, codename)


def iter_series(branches):
    for b in branches:
        (pocket, codename) = parse_branch(b)
        if codename is None:
            for (codename, version) in build_series.items():
                yield (Series(codename, version), pocket)
        else:
            yield (Series(codename, build_series[codename]), pocket)


def expand_series(branches):
    result = {}
    for (series, pocket) in iter_series(branches):
        if series not in result:
            result[series] = set()
        result[series].add(pocket)
    return result


def read_source_package_name(cwd):
    control = path.join(cwd, 'debian', 'control')
    with open(control, 'r') as fp:
        (key, value) = fp.readline().rstrip().split(': ')
        assert key == 'Source'
        return value


def mk_changelog(cwd, _id, series, datetime):
    return CHANGELOG.format(
        name=read_source_package_name(cwd),
        version='~'.join(['0', _id, series.version]),
        codename=series.codename,
        maintainer='Pop Launchpad <pop.launchpad@system76.com>',
        datetime=datetime,
    )


def write_changelog(cwd, _id, series, datetime):
    changelog = mk_changelog(cwd, _id, series, datetime)
    print(changelog)
    with open(path.join(cwd, 'debian', 'changelog'), 'w') as fp:
        fp.write(changelog)


def build_stuff_we_need(cwd):
    name = path.basename(cwd)

    print('')
    iprint(0, cwd)

    name_dir = path.join(SOURCE_DIR, name)
    os.mkdir(name_dir)

    ids = git_ids_and_branches(cwd)
    for (_id, branches) in sorted(ids.items()):
        iprint(1, _id)

        id_dir = path.join(name_dir, _id)
        os.mkdir(id_dir)

        datetime = git_datetime_id(cwd, _id)
        archive = git_archive_id(cwd, _id)

        expanded = expand_series(branches)
        for (series, pockets) in sorted(expanded.items()):
            iprint(2, series)

            series_dir = path.join(id_dir, series.codename)
            os.mkdir(series_dir)

            source_dir = path.join(series_dir, "source")
            os.mkdir(source_dir)
            check_output(["tar", "x"], input=archive, cwd=source_dir)

            if not path.isdir(path.join(source_dir, 'debian')):
                 print('No debian/ dir: {!r}'.format(source_dir))
                 continue

            write_changelog(source_dir, _id, series, datetime)

            check_call(['dpkg-source', '--build', source_dir], cwd=series_dir)

            for p in sorted(pockets):
                iprint(3, p)


def callback(repo):
    name =  repo['name']
    if name in (
        'code-of-conduct',
        'docs',
        'gnome-control-center',
        'gnome-initial-setup',
        'iso',
        'icon-theme',
        'shop',
        'wallpapers'
    ):
        print('skipping {!r}'.format(name))
        return
    cwd = path.join(POP_DIR, name)
    if path.exists(cwd):
        build_stuff_we_need(cwd)


def recreate_dir(d):
    if path.isdir(d):
        shutil.rmtree(d)
    os.mkdir(d)


def build_sources():
    recreate_dir(BUILD_DIR)
    #if not path.exists(SOURCE_DIR):
    os.mkdir(SOURCE_DIR)
    foreach_repo(callback, args.repos)


build_sources()
